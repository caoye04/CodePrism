{
  "directive": {
    "D_01_01": "Any implementation-defined behaviour on which the output of the program depends shall be documented and understood",
    "D_02_01": "All source files shall compile without any compilation errors",
    "D_03_01": "All code shall be traceable to documented requirements",
    "D_04_01": "Run-time failures shall be minimized",
    "D_04_02": "All usage of assembly language should be documented",
    "D_04_03": "Assembly language shall be encapsulated and isolated",
    "D_04_04": "Sections of code should not be 'commented out'",
    "D_04_05": "Identifiers in the same namespace with overlapping visibility should be typographically unambiguous",
    "D_04_06": "typedefs that indicate size and signedness should be used in place of the basic numerical types",
    "D_04_07": "If a function returns error information, then that error information shall be tested",
    "D_04_09": "A function should be used in preference to a function-like macro where they are interchangeable",
    "D_04_10": "Precautions shall be taken in order to prevent the contents of a header file being included more than once",
    "D_04_11": "The validity of values passed to library functions shall be checked",
    "D_04_12": "Dynamic memory allocation shall not be used",
    "D_04_13": "Functions which are designed to provide operations on a resource should be called in an appropriate sequence",
    "D_04_14": "The validity of values received from external sources shall be checked"
  },
  "rule": {
    "R_01_01": "The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation's translation limits",
    "R_01_02": "Language extensions should not be used",
    "R_01_03": "There shall be no occurrence of undefined or critical unspecified behaviour",
    "R_02_02": "There shall be no dead code",
    "R_02_03": "A project should not contain unused type declarations",
    "R_02_04": "A project should not contain unused tag declarations",
    "R_02_05": "A project should not contain unused macro declarations",
    "R_02_06": "A function should not contain unused label declarations",
    "R_02_07": "There should be no unused parameters in functions",
    "R_03_01": "The character sequences /* and // shall not be used within a comment",
    "R_03_02": "Line-splicing shall not be used in // comments",
    "R_04_01": "Octal and hexadecimal escape sequences shall be terminated",
    "R_04_02": "Trigraphs should not be used",
    "R_05_02": "Identifiers declared in the same scope and name space shall be distinct",
    "R_05_03": "An identifier declared in an inner scope shall not hide an identifier declared in an outer scope",
    "R_05_04": "Macro identifiers shall be distinct",
    "R_05_05": "Identifiers shall be distinct from macro names",
    "R_05_06": "A typedef name shall be a unique identifier",
    "R_05_07": "A tag name shall be a unique identifier",
    "R_06_01": "Bit-fields shall only be declared with an appropriate type",
    "R_06_02": "Single-bit named bit fields shall not be of a signed type",
    "R_07_01": "Octal constants shall not be used",
    "R_07_02": "A \"u\" or \"U\" suffix shall be applied to all integer constants that are represented in an unsigned type",
    "R_07_03": "The lowercase character 'l' shall not be used in a literal suffix",
    "R_07_04": "A string literal shall not be assigned to an object unless the object's type is \"pointer to const-qualified char\"",
    "R_08_01": "Types shall be explicitly specified",
    "R_08_02": "Function types shall be in prototype form with named parameters",
    "R_08_03": "All declarations of an object or function shall use the same names and type qualifiers",
    "R_08_04": "A compatible declaration shall be visible when an object or function with external linkage is defined",
    "R_08_08": "The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage",
    "R_08_09": "An object should be defined at block scope if its identifier only appears in a single function",
    "R_08_10": "An inline function shall be declared with the static storage class",
    "R_08_12": "Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique",
    "R_08_14": "The restrict type qualifier shall not be used",
    "R_09_01": "The value of an object with automatic storage duration shall not be read before it has been set",
    "R_09_02": "The initializer for an aggregate or union shall be enclosed in braces",
    "R_09_03": "Arrays shall not be partially initialized",
    "R_09_04": "An element of an object shall not be initialised more than once",
    "R_09_05": "Where designated initialisers are used to initialize an array object the size of the array shall be specified explicitly",
    "R_10_01": "Operands shall not be of an inappropriate essential type",
    "R_10_02": "Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations",
    "R_10_03": "The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category",
    "R_10_04": "Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category",
    "R_10_05": "The value of an expression should not be cast to an inappropriate essential type",
    "R_10_06": "The value of a composite expression shall not be assigned to an object with wider essential type",
    "R_10_07": "If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type",
    "R_10_08": "The value of a composite expression shall not be cast to a different essential type category or a wider essential type",
    "R_11_01": "Conversions shall not be performed between a pointer to a function and any other type",
    "R_11_02": "Conversions shall not be performed between a pointer to incomplete and any other type",
    "R_11_03": "A cast shall not be performed between a pointer to object type and a pointer to a different object type",
    "R_11_04": "A conversion should not be performed between a pointer to object and an integer type",
    "R_11_05": "A conversion should not be performed from pointer to void into pointer to object",
    "R_11_06": "A cast shall not be performed between pointer to void and an arithmetic type",
    "R_11_07": "A cast shall not be performed between pointer to object and a non-integer arithmetic type",
    "R_11_08": "A cast shall not remove any const or volatile qualification from the type pointed to by a pointer",
    "R_11_09": "The macro NULL shall be the only permitted form of integer null pointer constant",
    "R_12_01": "The precedence of operators within expressions should be made explicit",
    "R_12_02": "The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand",
    "R_12_03": "The comma operator should not be used",
    "R_12_04": "Evaluation of constant expressions should not lead to unsigned integer wrap-around",
    "R_12_05": "The sizeof operator shall not have an operand which is a function parameter declared as \"array of type\"",
    "R_13_02": "The value of an expression and its persistent side-effects shall be the same under all permitted evaluation orders",
    "R_13_03": "A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator",
    "R_13_04": "The result of an assignment operator should not be used",
    "R_13_06": "The operand of the sizeof operator shall not contain any expression which has potential side-effects",
    "R_14_01": "A loop counter shall not have essentially floating type",
    "R_14_02": "A for loop shall be well-formed",
    "R_14_03": "Controlling expressions shall not be invariant",
    "R_14_04": "The controlling expression of an if-statement and the controlling expression of an iteration-statement shall have essentially Boolean type",
    "R_15_01": "The goto statement should not be used",
    "R_15_02": "The goto statement shall jump to a label declared later in the same function",
    "R_15_03": "Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement",
    "R_15_04": "There should be no more than one break or goto statement used to terminate any iteration statement",
    "R_15_05": "A function should have a single point of exit at the end",
    "R_15_06": "The body of an iteration-statement or a selection-statement shall be a compound statement",
    "R_15_07": "All if ... else if constructs shall be terminated with an else statement",
    "R_16_01": "All switch statements shall be well-formed",
    "R_16_02": "A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement",
    "R_16_03": "An unconditional break statement shall terminate every switch-clause",
    "R_16_04": "Every switch statement shall have a default label",
    "R_16_05": "A default label shall appear as either the first or the last switch label of a switch statement",
    "R_16_06": "Every switch statement shall have at least two switch-clauses",
    "R_16_07": "A switch-expression shall not have essentially Boolean type",
    "R_17_01": "The features of <stdarg.h> shall not be used",
    "R_17_02": "Functions shall not call themselves, either directly or indirectly",
    "R_17_03": "A function shall not be declared implicitly",
    "R_17_04": "All exit paths from a function with non-void return type shall have an explicit return statement with an expression",
    "R_17_05": "The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements",
    "R_17_06": "The declaration of an array parameter shall not contain the static keyword between the [ ]",
    "R_17_07": "The value returned by a function having non-void return type shall be used",
    "R_17_08": "A function parameter should not be modified",
    "R_18_01": "A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand",
    "R_18_02": "Subtraction between pointers shall only be applied to pointers that address elements of the same array",
    "R_18_03": "The relational operators >, >=, < and <= shall not be applied to objects of pointer type except where they point into the same object",
    "R_18_04": "The +, -, += and -= operators should not be applied to an expression of pointer type",
    "R_18_05": "Declarations should contain no more than two levels of pointer nesting",
    "R_18_07": "Flexible array members shall not be declared",
    "R_18_08": "Variable-length array types shall not be used",
    "R_19_01": "An object shall not be assigned or copied to an overlapping object",
    "R_19_02": "The union keyword should not be used",
    "R_20_01": "#include directives should only be preceded by preprocessor directives or comments",
    "R_20_02": "The ', \" or \\ characters and the /* or // character sequences shall not occur in a header file name",
    "R_20_03": "The #include directive shall be followed by either a <filename> or \"filename\" sequence",
    "R_20_04": "A macro shall not be defined with the same name as a keyword",
    "R_20_05": "#undef should not be used",
    "R_20_06": "Tokens that look like a preprocessing directive shall not occur within a macro argument",
    "R_20_07": "Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses",
    "R_20_08": "The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1",
    "R_20_09": "All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation",
    "R_20_10": "The # and ## preprocessor operators should not be used",
    "R_20_11": "A macro parameter immediately following a # operator shall not immediately be followed by a ## operator",
    "R_20_12": "A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators",
    "R_20_13": "A line whose first token is # shall be a valid preprocessing directive",
    "R_20_14": "All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related",
    "R_21_01": "#define and #undef shall not be used on a reserved identifier or reserved macro name",
    "R_21_02": "A reserved identifier or reserved macro name shall not be declared",
    "R_21_03": "The memory allocation and deallocation functions of <stdlib.h> shall not be used",
    "R_21_04": "The standard header file <setjmp.h> shall not be used",
    "R_21_05": "The standard header file <signal.h> shall not be used",
    "R_21_06": "The Standard Library input/output routines shall not be used",
    "R_21_07": "The Standard Library functions atof, atoi, atol and atoll of <stdlib.h> shall not be used",
    "R_21_08": "The Standard Library functions abort, exit, getenv and system of <stdlib.h> shall not be used",
    "R_21_09": "The library functions bsearch and qsort of <stdlib.h> shall not be used",
    "R_21_10": "The Standard Library time and date routines shall not be used",
    "R_21_11": "The standard header file <tgmath.h> shall not be used",
    "R_21_12": "The exception handling features of <fenv.h> should not be used",
    "R_21_13": "Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF",
    "R_21_14": "The Standard Library function memcmp shall not be used to compare null terminated strings",
    "R_21_15": "The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types",
    "R_21_16": "The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type",
    "R_21_17": "Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters",
    "R_21_18": "The size_t argument passed to any function in <string.h> shall have an appropriate value",
    "R_21_19": "The pointers returned by the Standard Library functions localeconv, getenv, setlocale or, strerror shall only be used as if they have pointer to const-qualified type",
    "R_21_20": "The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function",
    "R_22_01": "All resources obtained dynamically by means of Standard Library functions shall be explicitly released",
    "R_22_02": "A block of memory shall only be freed if it was allocated by means of a Standard Library function",
    "R_22_03": "The same file shall not be open for read and write access at the same time on different streams",
    "R_22_04": "There shall be no attempt to write to a stream which has been opened as read-only",
    "R_22_05": "A pointer to a FILE object shall not be dereferenced",
    "R_22_06": "The value of a pointer to a FILE shall not be used after the associated stream has been closed",
    "R_22_07": "The macro EOF shall only be compared with the unmodified return value from any Standard Library function capable of returning EOF",
    "R_22_08": "The value of errno shall be set to zero prior to a call to an errno-setting-function",
    "R_22_09": "The value of errno shall be tested against zero after calling an errno-setting-function",
    "R_22_10": "The value of errno shall only be tested when the last function to be called was an errno-setting-function"
  }
}